/* markov.c */#include <stdlib.h>#include <time.h>#include <math.h>#include "ext.h"  		// you must include this - it contains the external object's link to available Max functions#include "ext_common.h"#include "ext_strings.h"#define RES_ID 10109	// this is the resource ID used in the resource file#define LOAD_MESSAGE1 "markov :: Nao Tokui :: 2001"#define LOAD_MESSAGE2 "**************************"typedef struct markov	// defines our object's internal variables for each instance in a patch{	t_object p_ob;		// object header - ALL objects MUST begin with this...	void *p_outlet;		// outlet creation - inlets are automatic, but objects must "own" their own outlets	void *p_outlet1;	void *p_outlet2;	void *p_outlet3;    //added by ali for new 'dumpout' message	short state_num;	short level;	short *table;	short *state_log;	short *init_state_log;	short verbose;} t_markov;void *markov_class;		// global pointer to the object class - so max can reference the object // these are prototypes for the methods that are defined belowvoid markov_bang(t_markov *x);void markov_int(t_markov *x, long n);void markov_float(t_markov *x, double n);void markov_list(t_markov *x, t_symbol *msg, short argc, t_atom *argv);void markov_state(t_markov *x);void markov_clear(t_markov *x);void markov_dump(t_markov *x);void markov_dumpout(t_markov *x);void markov_verbose(t_markov *x, long n);void markov_reset(t_markov *x, t_symbol *msg, short argc, t_atom *argv);void markov_count(t_markov *x, t_symbol *msg, short argc, t_atom *argv);void markov_assist(t_markov *x, void *b, long m, long a, char *s);void *markov_new(long n1, long n2);void markov_table_alloc(t_markov *x);void markov_table_init(t_markov *x);void markov_verbose_out(t_markov *x);int to_table_index(t_markov *x,short argc, t_atom *argv);int list_check(t_markov *x, short argc, t_atom *argv);int refer_table(t_markov *x,short argc, short *argv);void store_table(t_markov *x,short argc, t_atom *argv);void state_change(t_markov *x, short new_state);void from_table_index(t_markov *x, int index, char *str);void from_table_index_ali(t_markov *x, int index, char *str);void argerror(char *s);//--------------------------------------------------------------------------int C74_EXPORT main(void){	setup((t_messlist **)&markov_class, (method)markov_new, 0L, (short)sizeof(t_markov), 0L, A_LONG, A_LONG, 0); 	// setup() loads our external into Max's memory so it can be used in a patch	// plussz_new = object creation method defined below, A_DEFLONG = its (optional) arguement is a long (32-bit) int 		addbang((method)markov_bang);		// the method it uses when it gets a bang in the left inlet 	addint((method)markov_int);			// the method for an int in the left inlet (inlet 0) //	addfloat((method)markov_float);	addmess((method)markov_list,"list",A_GIMME, 0); 	addmess((method)markov_state,"state", 0); 	addmess((method)markov_clear,"clear", 0); 	addmess((method)markov_reset,"reset", A_GIMME, 0);	addmess((method)markov_count,"count", A_GIMME, 0);	 	addmess((method)markov_dump,"dump", 0); 	addmess((method)markov_dumpout,"dumpout", 0);		addmess((method)markov_verbose,"verbose",A_LONG,0);//	addinx((method)plussz_in1, 1);		// the method for an int in the right inlet (inlet 1) 	addmess((method)markov_assist, "assist", A_CANT, 0); // (optional) assistance method needs to be declared like this		rescopy('STR#', RES_ID);			// copy the 'STR#' resource from the resource file (used for assistance)		post(LOAD_MESSAGE1,0);	// post any important info to the max window when our object is laoded}//--------------------------------------------------------------------------void markov_bang(t_markov *x)		// x = reference to this instance of the object {   int state;   int i;      state = refer_table(x,x->level,x->state_log);       if (state==-1){     outlet_bang(x->p_outlet1); // stucked!!!          if (x->init_state_log[0]!=-1){     	for (i=0;i<x->level;i++)     	x->state_log[i]=x->init_state_log[i];     }   }else{   	state_change(x,state);   	if (x->verbose) {   		markov_verbose_out(x);   	}   	outlet_int(x->p_outlet, state); // to the next state!!!   }}//--------------------------------------------------------------------------void markov_int(t_markov *x, long n)	// x = the instance of the object; n = the int received in the left inlet {	double random_float;							// local variable for this method		random_float = ((double)rand() / (double)RAND_MAX) * (double)n;	// add left and right operands	outlet_float(x->p_outlet, random_float);	// send out the sum on bang 	}//--------------------------------------------------------------------------void markov_float(t_markov *x, double n)	// x = the instance of the object; n = the int received in the left inlet {	double random_float;							// local variable for this method		random_float = ((double)rand() / (double)RAND_MAX) * n;	// add left and right operands	outlet_float(x->p_outlet, random_float);	// send out the sum on bang }//--------------------------------------------------------------------------void  markov_list(t_markov *x, t_symbol *msg, short argc, t_atom *argv){  int check;  int i;    /* Checking list */  check=list_check(x,argc,argv);  if (check==0){  	error("markov: bad list message format",0);  	return;  }  if (check==-1) {    error("markov: state id must be 0 ... %d", x->state_num-1);  	return;  }    if (argc!=x->level+2&&argc!=x->level){  	error("markov: bad list message format",0);  	return;  }    /* stored to table */  if (argc ==x->level+2) store_table(x,argc,argv);   /* setting current state */    else if (argc==x->level){   for (i=0;i<x->level;i++){   		x->state_log[i]=argv[i].a_w.w_long;	   }  }}//--------------------------------------------------------------------------void markov_state(t_markov *x){ int i,len; char str[128]; char tmp[5]; str[0]=NULL;  for (i=0;i<x->level;i++){ 	sprintf(tmp, "%d ", x->state_log[i]);		len=strlen(str);	strcpy(str+len,tmp); } post("current state history:"); post(str);}//--------------------------------------------------------------------------void markov_verbose(t_markov *x,long n){	x->verbose = n;}//--------------------------------------------------------------------------void markov_clear(t_markov *x){  markov_table_init(x);  }//--------------------------------------------------------------------------void markov_assist(t_markov *x, void *b, long m, long a, char *s) // 4 final arguments are always the same for the assistance method{	assist_string(RES_ID,m,a,1,2,s); 	// get text (character strings) from the 'STR#' resource we loaded										// 1 = first text string for the inlets, 3 = first text string for the outlets}//--------------------------------------------------------------------------void *markov_new(long n1, long n2)		// n = int argument typed into object box (A_DEFLONG) -- defaults to 0 if no args are typed{	int i;	t_markov *x;				// local variable (pointer to a t_plussz data structure)	x = (t_markov *)newobject(markov_class); // create a new instance of this object		x->verbose = 0;	x->table = NULL;//	intin(x);					// create a second int inlet (leftmost inlet is automatic - all objects have one inlet by default)			x->p_outlet3 = outlet_new(x,0L);  //added by ali for new 'dumpout' message	x->p_outlet2 = listout(x);	x->p_outlet1 = bangout(x);	x->p_outlet = intout(x);	// create an int outlet and assign it to our outlet variable in the instance's data structure	//	x->p_value0	= 0;			// set initial (default) left operand value in the instance's data structure//	x->p_value1	= n;			// set initial (default) right operand value (n = variable passed to plussz_new)		srand(time(NULL));	x->state_num = n1;	x->level = n2;	markov_table_alloc(x);		x->state_log = malloc(sizeof(short)*x->level);	for (i=0;i<x->level;i++) x->state_log[i]=0;	x->init_state_log = malloc(sizeof(short)*x->level);	for (i=0;i<x->level;i++) x->init_state_log[i]=-1;		return(x);					// return a reference to the object instance }//--------------------------------------------------------------------------void markov_table_alloc(t_markov *x){  long elements;  elements = pow(x->state_num, x->level+1);    if (x->table!=NULL){	free(x->table);  } else {     x->table = malloc(sizeof(short)*elements);  }    markov_table_init(x);  }//--------------------------------------------------------------------------void markov_table_init(t_markov *x){  int i;  long elements;  elements = pow(x->state_num, x->level+1);  for (i=0;i<elements;i++){  	x->table[i] = 0;  }}//--------------------------------------------------------------------------int list_check(t_markov *x, short argc, t_atom *argv){   int i;      for (i=0;i<argc;i++){    if (argv[i].a_type != A_LONG) return 0;        if (i>x->level) {    	if(argv[i].a_w.w_long<0) return 0;	    } else {    	if(argv[i].a_w.w_long<0||argv[i].a_w.w_long>=x->state_num) return -1;   	}   }      return 1;}//--------------------------------------------------------------------------int to_table_index(t_markov *x, short argc, t_atom *argv){  int i;  int index;    index=0;    for (i=0;i<x->level+1;i++){     index+=pow(x->state_num,(x->level-i))*argv[i].a_w.w_long;  }    return index;}//--------------------------------------------------------------------------void store_table(t_markov *x,short argc, t_atom *argv){  int table_idx;    table_idx = to_table_index(x,argc,argv);    if (argc ==x->level+2) {  	x->table[table_idx] = argv[argc-1].a_w.w_long;  } else {  	++(x->table[table_idx]);  }}//--------------------------------------------------------------------------int refer_table(t_markov *x,short argc, short *argv){  int i,sum;  int idx_start,idx_end;  double rand_v;    idx_start=0;  for (i=0;i<x->level;i++){     idx_start+=pow(x->state_num,(x->level-i))*argv[i];  }  idx_end=idx_start+x->state_num;    sum=0;  for (i=idx_start;i<idx_end;i++){	sum += x->table[i];    }  if (sum==0) return -1;    rand_v = (double)sum*(double)rand()/(double)RAND_MAX;    sum=0;  for (i=idx_start;i<idx_end;i++){	sum += x->table[i]; 	if (sum>rand_v) break;   }   return i-idx_start;}//--------------------------------------------------------------------------void state_change(t_markov *x, short new_state){  int i;    for (i=1;i<x->level;i++){  	x->state_log[i-1]=x->state_log[i];  }	    x->state_log[x->level-1]=new_state;}//--------------------------------------------------------------------------void argerror(char *s){	error("markov: bad arguments for message \'%s\'",s);}//--------------------------------------------------------------------------void markov_dump(t_markov *x){	int i,len;	long elements;	char str[128];	char str2[10];  	elements = pow(x->state_num, x->level+1); 	post("transition probabilities:");	for(i=0;i<elements;i++){		if (x->table[i]!=0){		 from_table_index(x,i,str);		 sprintf(str2,": %d",x->table[i]);		 len = strlen(str);		 strcpy(str+len, str2);		 post(str);//			post("%d has weight %d", i,x->table[i]);//			sprintf(dest,"%")		}		}}//--------------------------------------------------------------------------void markov_dumpout(t_markov *x){	int i,len;	long elements;	char str[128];	char str2[10];  	elements = pow(x->state_num, x->level+1); 	// post("transition probabilities:");	for(i=0;i<elements;i++){		if (x->table[i]!=0){		 from_table_index_ali(x,i,str);		 sprintf(str2,"%d",x->table[i]);		 len = strlen(str);		 strcpy(str+len, str2);	//	 post(str);	outlet_anything(x->p_outlet3,gensym(str),0L,NIL);//			post("%d has weight %d", i,x->table[i]);//			sprintf(dest,"%")		}		}}//--------------------------------------------------------------------------void markov_verbose_out(t_markov *x){  	t_atom * p_value;  	int i,sum;  	int idx_start,idx_end;  	double rand_v;    	p_value = (t_atom *)getbytes(sizeof(t_atom)*(x->state_num));   	  	idx_start=0;  	for (i=0;i<x->level;i++){     	idx_start+=pow(x->state_num,(x->level-i))*x->state_log[i];  	}  	idx_end=idx_start+x->state_num;    	sum=0;  	for (i=idx_start;i<idx_end;i++){		sum += x->table[i];    	}  		for (i=idx_start;i<idx_end;i++){		if (sum!=0) A_SETFLOAT(&p_value[i-idx_start],(double)x->table[i]/(double)sum);		else A_SETFLOAT(&p_value[i-idx_start],0.0);  	}	outlet_list(x->p_outlet2,0L,x->state_num,p_value);		freebytes(p_value, sizeof(t_atom)*(x->state_num));}//--------------------------------------------------------------------------void markov_reset(t_markov *x, t_symbol *msg, short argc, t_atom *argv){	int i;		if (argc!=x->level||list_check(x,argc,argv)!=1) {		argerror("reset");	 	return;	}		for (i=0;i<x->level;i++){		x->init_state_log[i] = argv[i].a_w.w_long;	}}//--------------------------------------------------------------------------void markov_count(t_markov *x, t_symbol *msg, short argc, t_atom *argv){	int check; 	    /* Checking list */  check=list_check(x,argc,argv);  if (check==0){	argerror("count");  	error("markov: bad list message format",0);  	return;  }  if (check==-1) {    argerror("count");    error("markov: state id must be 0 ... %d", x->state_num-1);  	return;  }    if (argc!=x->level+1){  	argerror("count");  	error("markov: bad list message format",0);  	return;  }    /* stored to table : (weight)++ */  store_table(x,argc,argv); }//--------------------------------------------------------------------------void from_table_index(t_markov *x, int index, char *str){	int i,len;	short state;	char str2[5];		str[0] = NULL;		for (i=0;i<x->level+1;i++){		state = index / (int)pow(x->state_num, x->level-i);		index = index % (int)pow(x->state_num, x->level-i);				if (i==x->level) sprintf(str2,"-> %d ",state);		else sprintf(str2,"%d ",state);		len=strlen(str);		strcpy(str+len,str2);	}}//--------------------------------------------------------------------------//added by ali for new dumpout messagevoid from_table_index_ali(t_markov *x, int index, char *str){	int i,len;	short state;	char str2[5];		str[0] = NULL;		for (i=0;i<x->level+1;i++){		state = index / (int)pow(x->state_num, x->level-i);		index = index % (int)pow(x->state_num, x->level-i);				if (i==x->level) sprintf(str2,"%d ",state);		else sprintf(str2,"%d ",state);		len=strlen(str);		strcpy(str+len,str2);	}}